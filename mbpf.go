package main

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"os/signal"
	"time"

	"github.com/cilium/ebpf/ringbuf"
	manager "github.com/ehids/ebpfmanager"
	"golang.org/x/sys/unix"
)

type bpfEvent struct {
	Pid  int32
	Comm [80]uint8
}

var m = &manager.Manager{
	Probes: []*manager.Probe{
		{
			UID:              "MySysExecve",
			Section:          "kprobe/sys_execve",
			EbpfFuncName:     "kprobe_execve",
			AttachToFuncName: "__x64_sys_execve",
		},
	},
	Maps: []*manager.Map{
		{
			Name: "events",
		},
	},
}

func main() {
	options := manager.Options{
		DefaultProbeRetry:      2,
		DefaultProbeRetryDelay: time.Second,
	}

	// Initialize the manager
	if err := m.InitWithOptions(recoverAssets(), options); err != nil {
		log.Fatal(err)
	}

	// Start the manager
	if err := m.Start(); err != nil {
		log.Fatal(err)
	}

	log.Println("successfully started")
	log.Println("=> Cmd+C to exit")

	procEventsMap, found, err := m.GetMap("events")
	if err != nil {
		log.Fatal(err)
	}
	if !found {
		log.Fatal(errors.New("cant found map:events"))
	}

	rd, err := ringbuf.NewReader(procEventsMap)
	if err != nil {
		log.Fatalf("opening ringbuf reader: %s", err)
	}
	defer rd.Close()

	readEvent(rd)

	wait()

	if err := rd.Close(); err != nil {
		log.Fatalf("closing ringbuf reader: %s", err)
	}

	// Close the manager
	if err := m.Stop(manager.CleanAll); err != nil {
		log.Fatal(err)
	}
}

// wait - Waits until an interrupt or kill signal is sent
func wait() {
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, os.Interrupt, os.Kill)
	<-sig
	log.Println("stop program")
}

// recoverAssets - Recover ebpf asset
func recoverAssets() io.ReaderAt {
	buf, err := Asset("/probe.o")
	if err != nil {
		log.Fatal(errors.New(fmt.Sprintf("error:%v , couldn't find asset", err)))
	}
	return bytes.NewReader(buf)
}

func readEvent(rd *ringbuf.Reader) {

	log.Println("Waiting for events..")

	// bpfEvent is generated by bpf2go.
	var event bpfEvent
	for {
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				log.Println("Received signal, exiting..")
				return
			}
			log.Printf("reading from reader: %s", err)
			continue
		}

		// Parse the ringbuf event entry into a bpfEvent structure.
		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &event); err != nil {
			log.Printf("parsing ringbuf event: %s", err)
			continue
		}

		log.Printf("pid: %d\tcomm: %s\n", event.Pid, unix.ByteSliceToString(event.Comm[:]))
	}
}
